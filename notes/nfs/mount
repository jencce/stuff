fs/nfs/inode.c
	module(init_nfs_fs) --> register_nfs_fs --> regster_fetm(&nfs4_fs_type)
						    regster_fletm(&nfs_fs_type)

struct file_system_type nfs_fs_type / nfs4_fs_type = {
        .owner          = THIS_MODULE,
        .name           = "nfs", / "nfs4",
        .mount          = nfs_fs_mount,       <-------------------------- POINT
        .kill_sb        = nfs_kill_super,
        .fs_flags       = FS_RENAME_DOES_D_MOVE|FS_BINARY_MOUNTDATA,
};


fs/namespace.c
	mount syscall --> do_mount --> do_new_mount --> XXX

	---------------------------------------------------------------
	mount -t nfs4  localhost:/root /nfsmnt
			||
			\/
	SYSCALL_DEFINE5(mount, char __user *, dev_name, char __user *, dir_name,
                char __user *, type, unsigned long, flags, void __user *, data)
			||
			\/
	jprobe: dev_name = localhost:/root, dir_name = /nfsmnt, type = nfs4,
	flags = 0x0, data = addr=::1,clientaddr=::1
	---------------------------------------------------------------

	IN do_mount, done mountpoint dir_name lookup, flags transformation,
	separate per-mountpoint flags to mnt_flags, clear useless flags:

	flags &= ~(MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_ACTIVE | MS_BORN |
                   MS_NOATIME | MS_NODIRATIME | MS_RELATIME| MS_KERNMOUNT |
                   MS_STRICTATIME);	

	and CALL:
	do_new_mount(&path, type_page, flags, mnt_flags, dev_name, data_page);

	IN do_new_mount, call get_fs_type to get nfs type registered in
	filesystems list,
	then CALL:
	vfs_kern_mount(struct file_system_type *type, int flags,
			const char *name, void *data)
	and call do_add_mount if success.

	XXX --> vfs_kern_mount --> mount_fs --> type->mount ==> nfs_fs_mount

	IN mount_fs, CALL:
		root = type->mount(type, flags, name, data);
	so comes nfs_fs_mount.


fs/nfs/super.c
	nfs_fs_mount --> nfs4_try_mount --> nfs_do_root_mount

	struct file_system_type nfs4_fs_type = {
        	.owner          = THIS_MODULE,
        	.name           = "nfs4",
        	.mount          = nfs_fs_mount,
        	.kill_sb        = nfs_kill_super,
        	.fs_flags       = FS_RENAME_DOES_D_MOVE|FS_BINARY_MOUNTDATA,
	};


	IN nfs_fs_mount,
	init struct nfs_mount_info mount_info, includes options and fhandle etc,
	then  validate all of them; 
	init struct nfs_subversion *nfs_mod, acorrding to fs_type,
	then CALL:
		mntroot = nfs_mod->rpc_ops->try_mount(flags, dev_name,
							&mount_info, nfs_mod);


	So we come to one particular nfs_subversion, eg nfs_v4, roc_ops struct:

fs/nfs/nfs4super.c
	IN nfs4_try_mount,
	replace export_path with "/", do_root_mount with remote_fs_type first,
	then replace back real export_path, call nfs_follow_remote_path:

	-------------------------------------------------------
	export_path = data->nfs_server.export_path;
        data->nfs_server.export_path = "/";
        root_mnt = nfs_do_root_mount(&nfs4_remote_fs_type, flags, mount_info,
					//   ^^^ NOTICE HERE
                        data->nfs_server.hostname);
        data->nfs_server.export_path = export_path;
        res = nfs_follow_remote_path(root_mnt, export_path);
	-------------------------------------------------------
	

	IN nfs_do_root_mount, just handle hostname, then CALL:
		vfs_kern_mount(fs_type, flags, root_devname, data);
	as vfs_kern_mount called before, with nfs4_remote_fs_type:

		static struct file_system_type nfs4_remote_fs_type = {
	        	.owner          = THIS_MODULE,
	        	.name           = "nfs4",
		        .mount          = nfs4_remote_mount,
        		.kill_sb        = nfs_kill_super,
		        .fs_flags       = FS_RENAME_DOES_D_MOVE|FS_BINARY_MOUNTDATA,
		};

	vfs_kern_mount --> mount_fs --> nfs4_remote_mount

	IN nfs4_remote_mount,
	first call server = nfs4_create_server(mount_info, &nfs_v4);
	then nfs_fs_mount_common(server, flags, dev_name, mount_info, &nfs_v4);

	nfs4_remote_mount --> nfs4_create_server
			  |
			  --> nfs_fs_mount_common

fs/nfs/nfs4client.c
	nfs4_create_server --> nfs4_init_server
			   |
			   --> nfs4_server_common_setup

	IN nfs4_create_server,
	alloc struct nfs_server and init some fields,
	call nfs4_init_server to setup client stuff,
		nfs4_init_server(server, mount_info->parsed);
	call nfs4_server_common_setup to setup.
		nfs4_server_common_setup(server, mnt_info->mtfh, auth_probe)



	nfs4_init_server --> nfs4_set_client
			 |
			  --> nfs_init_server_rpcclient

	IN nfs4_init_server:
	continue init struct nfs_server with parsed data,
	call nfs4_set_client with strcut and some mount info,
	call nfs_init_server_rpcclient.

	IN nfs4_set_client:
	call nfs_get_client:
	find a nfs_client matches parsed data if it exists, OR alloc and init
	a nfs_client with nfsv4 rpc_ops funcs,

	nfs4_set_client --> nfs_get_client --> nfs4_init_client
						|
						v
			rpc_create <-- nfs_create_rpc_client

	IN nfs4_init_client:
	call nfs_create_rpc_client with RPC_AUTH_GSS_KRB5I, if fail then with
	RPC_AUTH_UNIX,
	call nfs_idmap_new and other funcs, TBD


net/sunrpc/clnt.c
	rpc_create -> xprt_create_transport -> xprt_class->setup(xs_setup_tcp)
		   |
		   --> rpc_create_xprt

	IN rpc_create,
	create a RPC transport with xprt_create_transport .. 
	then call rpc_create_xprt create an client with transport and return.
	
	IN xprt_create_transport,
	find the right xprt_class in xprt_list for this RPC, classes are ident
	with below categories:
	
	static struct xprt_class xs_tcp_transport = {
	        .list           = LIST_HEAD_INIT(xs_tcp_transport.list),
        	.name           = "tcp",
	        .owner          = THIS_MODULE,
        	.ident          = XPRT_TRANSPORT_TCP,
	        .setup          = xs_setup_tcp,
	};

	enum xprt_transports {
        	XPRT_TRANSPORT_UDP      = IPPROTO_UDP,
        	XPRT_TRANSPORT_TCP      = IPPROTO_TCP,
	        XPRT_TRANSPORT_BC_TCP   = IPPROTO_TCP | XPRT_TRANSPORT_BC,
        	XPRT_TRANSPORT_RDMA     = 256,
       		XPRT_TRANSPORT_LOCAL    = 257,
	};


	IN xs_setup_tcp:

Then vfs_kern_mount call registered function nfs4_get_sb do most of the work.
nfs4_get_sb --> nfs4_try_mount --> nfs_do_root_mount
Then  goes to nfs4_remote_get_sb --> nfs4_create_server --> nfs4_init_server --> nfs4_set_client 


Back to nfs4_try_mount, after nfs_do_root_mount, calls nfs_follow_remote_path --> vfs_path_lookup --> path_walk --> .. -> do_lookup --> follow_managed --> follow_automount --> dentry->d_op->d_automount
