1. by Bruce Fields
GDB Tricks

When you encounter an OOPS, you'll get a Call trace like:

Call Trace:

[<ffffffff8110a3ef>] kfree+0x63/0xfc
[<ffffffffa011e18e>] nfs_free_parsed_mount_data+0x24/0xc1 [nfs]
[<ffffffffa0121743>] nfs_fs_mount+0x5ac/0x61c [nfs]
[<ffffffff81116a8d>] mount_fs+0x69/0x158
[<ffffffff810ea5ad>] ? __alloc_percpu+0x10/0x12
[<ffffffff8112b8a8>] vfs_kern_mount+0x65/0xc4
[<ffffffff8112bf07>] do_kern_mount+0x4d/0xdf
[<ffffffff8112d6b7>] do_mount+0x64b/0x6af
[<ffffffff8112cfd0>] ? copy_mount_options+0xcb/0x12e
[<ffffffff8112d81e>] sys_mount+0x88/0xc2
[<ffffffff81426be9>] system_call_fastpath+0x16/0x1b

There is a simple way to translate a <symbol>/<offset> to a line number:

    run gdb passing the correct kernel module (.ko) as the only argument
    use the "l * (<symbol>+<offset>)" command 


$ gdb obj/fs/nfs/nfs.ko 

...

(gdb) l * (nfs_free_parsed_mount_data+0x24)
0x918e is in nfs_free_parsed_mount_data (/home/dros/build/src/fs/nfs/super.c:924).
919	
920	static void nfs_free_parsed_mount_data(struct nfs_parsed_mount_data *data)
921	{
922		if (data) {
923			kfree(data->client_address);
924			kfree(data->mount_server.hostname);
925			kfree(data->nfs_server.export_path);
926			kfree(data->nfs_server.hostname);
927			kfree(data->fscache_uniq);
928			security_free_mnt_opts(&data->lsm_opts);


2. crash
crash> bt -F
PID: 385    TASK: ffff8802300ff1c0  CPU: 0   COMMAND: "kworker/0:1H"
    [exception RIP: xfs_dir3_block_read_verify+47]
    RIP: ffffffffa01b434f  RSP: ffff88022f59fdb0  RFLAGS: 00010246
    RAX: 0000000000000000  RBX: ffff8800448be100  RCX: dead000000200200
    RDX: ffffffffa01ef260  RSI: 0d00000000000000  RDI: ffff8800448be100
    RBP: ffff88022f59fdd8   R8: ffff8800448be1a8   R9: dffe75d0be0be1a0
    R10: dffe75d0be0be1a0  R11: 0000000000000400  R12: ffff8800448be100
    R13: ffff880237214280  R14: ffff88023721c200  R15: 0000000000000020
    CS: 0010  SS: 0018
...
crash> gdb list *xfs_dir3_block_read_verify+47
0xffffffffa01b43ef is in xfs_dir3_block_read_verify (fs/xfs/xfs_sb.h:630).
625     /*
626      * V5 superblock specific feature checks
627      */
628     static inline int xfs_sb_version_hascrc(xfs_sb_t *sbp)
629     {
630             return XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;
631     }
632
crash> dis xfs_dir3_block_read_verify+47
0xffffffffa01b434f <xfs_dir3_block_read_verify+47>:     movzwl 0x7c(%rax),%eax
sh> p *((struct xfs_buf *) 0xffff8800448be100)
...
  b_target = 0xffff88012fa3b440,
...
  b_ops = 0xffffffffa01ef250 <xfs_dir3_block_buf_ops>
}
crash> p *((struct xfs_buf *) 0xffff8800448be100)->b_target
$75 = {
  bt_dev = 2,
  bt_bdev = 0x0,
  bt_bdi = 0x0,
  bt_mount = 0x0,
  bt_meta_sectorsize = 0,
  bt_meta_sectormask = 0,
  bt_logical_sectorsize = 137438953471,
  bt_logical_sectormask = 137438953471,
  bt_shrinker = {
    shrink = 0x1fffffffff,
    seeks = 0,
    batch = 0,
    list = {
      next = 0x0,
      prev = 0x0
    },
    nr_in_batch = {
      counter = 0
    }
  },
  bt_lru = {
    next = 0xffff880180fce880,
    prev = 0xffffffff8193a2a0 <root_user>
  },
  bt_lru_lock = {
    {
      rlock = {
        raw_lock = {
          {
            head_tail = 2173936416,
            tickets = {
              head = 41760,
              tail = 33171
            }
          }
        }
      }
    }
  },
  bt_lru_nr = 4294967295
}


3. code

https://bugzilla.redhat.com/show_bug.cgi?id=995189#c3

I think I found the location. I took the code of:

49 81 c1 00 00 10 00 49 89 c2 49 81 e2 00 00 f0 ff 4d 0f b1 10 4d 89 c8 4c 89 c8 49 81 e0 00 00 f0 ff 4c 0f b1 07 49 8b 44 24 30 <48> c7 40 08 00 00 00 00 48 89 c8 f0 4c 0f b1 63 30 48 39 c1 74

Replaced "<48>" with "48", then ran it through:

echo 49 81 c1 00 00 10 00 49 89 c2 49 81 e2 00 00 f0 ff 4d 0f b1 10 4d 89 c8 4c 89 c8 49 81 e0 00 00 f0 ff 4c 0f b1 07 49 8b 44 24 30 <48> c7 40 08 00 00 00 00 48 89 c8 f0 4c 0f b1 63 30 48 39 c1 74 | perl -e '$a=<>; chomp $a; @b = split / /,$a; $t = ""; foreach $y (@b) { $y = hex $y; $t = "C".$t; } $bin = pack $t, @b; print $bin;' > /tmp/binary

Then I did:

objdump -D -b binary -mi386 -Mx86-64 /tmp/binary

Which gave me:

00000000 <.data>:
   0:   49 81 c1 00 00 10 00    add    $0x100000,%r9
   7:   49 89 c2                mov    %rax,%r10
   a:   49 81 e2 00 00 f0 ff    and    $0xfffffffffff00000,%r10
  11:   4d 0f b1 10             cmpxchg %r10,(%r8)
  15:   4d 89 c8                mov    %r9,%r8
  18:   4c 89 c8                mov    %r9,%rax
  1b:   49 81 e0 00 00 f0 ff    and    $0xfffffffffff00000,%r8
  22:   4c 0f b1 07             cmpxchg %r8,(%rdi)
  26:   49 8b 44 24 30          mov    0x30(%r12),%rax
  2b:   48 c7 40 08 00 00 00    movq   $0x0,0x8(%rax) <<<- bug here
  32:   00 
  33:   48 89 c8                mov    %rcx,%rax
  36:   f0 4c 0f b1 63 30       lock cmpxchg %r12,0x30(%rbx)
  3c:   48 39 c1                cmp    %rax,%rcx
  3f:   74                      .byte 0x74

This seems to be the location of rb_tail_page_update():

		(void)local_cmpxchg(&next_page->write, old_write, val);
		(void)local_cmpxchg(&next_page->entries, old_entries, eval);

		/*
		 * No need to worry about races with clearing out the commit.
		 * it only can increment when a commit takes place. But that
		 * only happens in the outer most nested commit.
		 */
		local_set(&next_page->page->commit, 0);

"commit" is at the 8 byte offset of page. So it seems that somehow next_page->page became NULL?

What were you doing at the time of tracing? Were you reading the buffers too? Running trace-cmd?

